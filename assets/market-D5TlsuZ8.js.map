{"version":3,"file":"market-D5TlsuZ8.js","sources":["../../src/utils/market.js"],"sourcesContent":["// src/utils/market.js\r\n// Market data functions (Azure first; no ESI fallbacks for orders)\r\n\r\nimport { fetchWithRetry, AZURE_BASE, ESI_BASE, fetchMarketTree, fetchStationsNPC, fetchStructures, fetchRegionOrdersSnapshot } from './api.js';\r\n\r\n// Simple localStorage cache for market history keyed by typeId:regionId\r\nconst HISTORY_CACHE_KEY = 'marketHistoryCache.v1';\r\n\r\nfunction readHistoryCache() {\r\n    try {\r\n        const raw = localStorage.getItem(HISTORY_CACHE_KEY);\r\n        return raw ? JSON.parse(raw) : {};\r\n    } catch {\r\n        return {};\r\n    }\r\n}\r\n\r\nfunction writeHistoryCache(cache) {\r\n    try {\r\n        localStorage.setItem(HISTORY_CACHE_KEY, JSON.stringify(cache));\r\n    } catch {\r\n        // ignore quota errors\r\n    }\r\n}\r\n\r\nexport async function fetchMarketOrders(typeId, regionId = null, locationId = null, isBuyOrder = null) {\r\n    const params = new URLSearchParams({ type_id: typeId });\r\n    if (regionId) params.append('region_id', regionId);\r\n    if (locationId) params.append('location_id', locationId);\r\n    if (isBuyOrder !== null) params.append('is_buy_order', isBuyOrder);\r\n\r\n    console.log(`ðŸŽ¯ Fetching market orders for type_id: ${typeId}, region_id: ${regionId}`);\r\n\r\n    try {\r\n        // 0) Try static region snapshot first (best quotes only), except PLEX region (19000001 has no snapshots)\r\n        const PLEX_REGION_ID = 19000001;\r\n        if (regionId && Number(regionId) !== PLEX_REGION_ID) {\r\n            try {\r\n                const snap = await fetchRegionOrdersSnapshot(regionId);\r\n                if (snap && snap.best_quotes && snap.best_quotes[typeId]) {\r\n                    const entry = snap.best_quotes[typeId];\r\n                    const buy = entry.best_buy ? [{ ...entry.best_buy, is_buy_order: true, type_id: typeId, region_id: regionId }] : [];\r\n                    const sell = entry.best_sell ? [{ ...entry.best_sell, is_buy_order: false, type_id: typeId, region_id: regionId }] : [];\r\n                    return { buyOrders: buy, sellOrders: sell, meta: { source: 'snapshot', last_updated: snap.last_updated } };\r\n                }\r\n            } catch { }\r\n        }\r\n\r\n        const url = `${AZURE_BASE}/market/orders?${params}`;\r\n        const response = await fetchWithRetry(url, {}, 1);\r\n        console.log('âœ… Azure response received:', response);\r\n\r\n        // Validate response structure\r\n        if (!response || typeof response !== 'object') {\r\n            throw new Error('Invalid response structure from Azure');\r\n        }\r\n\r\n        // Ensure we have the expected structure\r\n        const result = {\r\n            buyOrders: response.buyOrders || [],\r\n            sellOrders: response.sellOrders || [],\r\n            meta: response.meta || {}\r\n        };\r\n\r\n        console.log(`ðŸ“Š Azure orders: ${result.buyOrders.length} buy, ${result.sellOrders.length} sell`);\r\n        return result;\r\n\r\n    } catch (azureError) {\r\n        console.error('âŒ Azure fetch failed for market orders:', azureError);\r\n        return { buyOrders: [], sellOrders: [], meta: { source: 'none' } };\r\n    }\r\n}\r\n\r\nexport async function fetchMarketSummary(typeId, regionId = null) {\r\n    const params = new URLSearchParams({ type_id: typeId });\r\n    if (regionId) params.append('region_id', regionId);\r\n    return fetchWithRetry(`${AZURE_BASE}/market/summary?${params}`, {}, 3);\r\n}\r\n\r\nexport async function fetchMarketHistory(type_id, region_id, days = 365) {\r\n    // Cache key and read existing cache\r\n    const key = `${type_id}:${region_id}`;\r\n    const cache = readHistoryCache();\r\n    const now = Date.now();\r\n\r\n    // Keep up to 365 days; if cached and fresh for today, return it\r\n    const cached = cache[key];\r\n    if (cached && Array.isArray(cached.data)) {\r\n        // If lastUpdated is today, serve cached\r\n        const last = new Date(cached.lastUpdated);\r\n        const sameDay = last.toDateString() === new Date(now).toDateString();\r\n        if (sameDay) {\r\n            return cached.data;\r\n        }\r\n    }\r\n\r\n    // ESI direct: https://esi.evetech.net/latest/markets/{region_id}/history/?type_id={type_id}\r\n    const url = `${ESI_BASE}/markets/${region_id}/history/?type_id=${encodeURIComponent(type_id)}`;\r\n    console.log(`ðŸ“ˆ Fetching market history from ESI: type_id=${type_id}, region_id=${region_id}`);\r\n\r\n    try {\r\n        const response = await fetch(url, { headers: { 'User-Agent': 'EVE-Data-Site' } });\r\n        if (!response.ok) {\r\n            throw new Error(`Failed to fetch market history: ${response.statusText} (${response.status})`);\r\n        }\r\n\r\n        const data = await response.json();\r\n        return persistHistory(key, now, cache, cached, data);\r\n    } catch (error) {\r\n        console.warn(`ðŸ“ˆ ESI history unavailable for type_id=${type_id}, region_id=${region_id}:`, error?.message || error);\r\n        if (cached && Array.isArray(cached.data)) return cached.data;\r\n        throw error;\r\n    }\r\n}\r\n\r\nfunction persistHistory(key, now, cache, cached, data) {\r\n    // Normalize and clamp to 365 days, sorted by date asc\r\n    const normalized = (Array.isArray(data) ? data : [])\r\n        .filter(e => e && e.date)\r\n        .sort((a, b) => new Date(a.date) - new Date(b.date))\r\n        .slice(-365);\r\n\r\n    // Merge with cached if present to avoid losing older days when API returns fewer\r\n    let merged = normalized;\r\n    if (cached && Array.isArray(cached.data) && cached.data.length) {\r\n        const map = new Map(cached.data.map(e => [e.date, e]));\r\n        for (const e of normalized) map.set(e.date, e);\r\n        merged = Array.from(map.values()).sort((a, b) => new Date(a.date) - new Date(b.date)).slice(-365);\r\n    }\r\n\r\n    cache[key] = { lastUpdated: now, data: merged };\r\n    writeHistoryCache(cache);\r\n    return merged;\r\n}\r\n\r\nexport async function fetchAggregatedOrders(typeId, regionId) {\r\n    const params = new URLSearchParams({ type_id: typeId, region_id: regionId });\r\n    return fetchWithRetry(`${AZURE_BASE}/aggregated-orders?${params}`, {}, 3);\r\n}\r\n\r\nexport async function fetchUniverseMarketHistory(typeId) {\r\n    console.log('ðŸŒ fetchUniverseMarketHistory called with typeID:', typeId, typeof typeId);\r\n\r\n    const hubs = [10000002, 10000043, 10000032, 10000030, 10000042]; // major trade hub regions\r\n    console.log('ðŸŒ Fetching from hubs:', hubs);\r\n\r\n    const historyLists = await Promise.all(hubs.map(async (rid) => {\r\n        try {\r\n            console.log(`ðŸŒ Fetching hub ${rid} for typeID ${typeId}`);\r\n            const result = await fetchMarketHistory(typeId, rid);\r\n            console.log(`ðŸŒ Hub ${rid} returned:`, result ? result.length : 'null', 'items');\r\n            if (result && result.length > 0) {\r\n                console.log(`ðŸŒ Sample data from hub ${rid}:`, result[0]);\r\n            }\r\n            return result;\r\n        } catch (error) {\r\n            console.error(`ðŸŒ Hub ${rid} failed:`, error);\r\n            return [];\r\n        }\r\n    }));\r\n\r\n    console.log('ðŸŒ All hub responses:', historyLists.map(list => Array.isArray(list) ? list.length : 'not array'));\r\n\r\n    // Aggregate by date across all regions\r\n    const dateMap = new Map();\r\n    historyLists.forEach((list, index) => {\r\n        console.log(`ðŸŒ Processing hub ${hubs[index]} with ${Array.isArray(list) ? list.length : 'not array'} items`);\r\n        if (Array.isArray(list)) {\r\n            list.forEach(entry => {\r\n                const date = entry.date;\r\n                if (!dateMap.has(date)) {\r\n                    dateMap.set(date, {\r\n                        date,\r\n                        totalVolume: 0,\r\n                        totalValue: 0,\r\n                        highest: 0,\r\n                        lowest: Infinity,\r\n                        orderCount: 0\r\n                    });\r\n                }\r\n                const bucket = dateMap.get(date);\r\n                const vol = entry.volume || 0;\r\n                const avg = entry.average || 0;\r\n                bucket.totalVolume += vol;\r\n                bucket.totalValue += vol * avg;\r\n                bucket.highest = Math.max(bucket.highest, entry.highest || 0);\r\n                bucket.lowest = Math.min(bucket.lowest, entry.lowest || bucket.lowest);\r\n                bucket.orderCount += entry.order_count || 0;\r\n            });\r\n        }\r\n    });\r\n\r\n    console.log('ðŸŒ Date map size:', dateMap.size);\r\n\r\n    // Convert to array with weighted average\r\n    const aggregated = Array.from(dateMap.values())\r\n        .map(item => ({\r\n            date: item.date,\r\n            average: item.totalVolume > 0 ? item.totalValue / item.totalVolume : 0,\r\n            totalVolume: item.totalVolume,\r\n            highest: item.highest,\r\n            lowest: item.lowest === Infinity ? 0 : item.lowest,\r\n            order_count: item.orderCount\r\n        }))\r\n        .sort((a, b) => new Date(a.date) - new Date(b.date));\r\n\r\n    console.log('ðŸŒ Final aggregated result:', aggregated.length, 'items');\r\n    if (aggregated.length > 0) {\r\n        console.log('ðŸŒ Sample aggregated item:', aggregated[0]);\r\n    }\r\n\r\n    return aggregated;\r\n}\r\n\r\nexport async function fetchTradeRouteData(fromId, toId, types = [34, 44992]) {\r\n    const opportunities = [];\r\n    for (const typeId of types) {\r\n        // Fetch sell orders (buying from source) and buy orders (selling to destination)\r\n        const sellResult = await fetchMarketOrders(typeId, fromId, null, false);\r\n        const buyResult = await fetchMarketOrders(typeId, toId, null, true);\r\n        const sellOrders = sellResult.sellOrders || [];\r\n        const buyOrders = buyResult.buyOrders || [];\r\n        if (sellOrders.length && buyOrders.length) {\r\n            const bestSell = Math.min(...sellOrders.map(o => o.price));\r\n            const bestBuy = Math.max(...buyOrders.map(o => o.price));\r\n            const profit = bestBuy - bestSell;\r\n            const profitPct = bestSell > 0 ? (profit / bestSell) * 100 : 0;\r\n            const maxSellVol = sellOrders.find(o => o.price === bestSell)?.volume_remain || 0;\r\n            const maxBuyVol = buyOrders.find(o => o.price === bestBuy)?.volume_remain || 0;\r\n            opportunities.push({\r\n                type_id: typeId,\r\n                buy_price: bestBuy,\r\n                sell_price: bestSell,\r\n                profit_per_unit: profit,\r\n                profit_percentage: profitPct,\r\n                max_volume: Math.min(maxSellVol, maxBuyVol),\r\n                from_region: fromId,\r\n                to_region: toId\r\n            });\r\n        }\r\n    }\r\n    // Sort by descending profit percentage\r\n    return opportunities.sort((a, b) => b.profit_percentage - a.profit_percentage);\r\n}\r\n\r\n// Deprecated: live region hauling API and precomputed artifacts are not used.\r\nexport async function fetchRegionHaulingData() { return []; }\r\n\r\n// Build cross-region trade routes from precomputed region_orders snapshots (best quotes per region)\r\nexport async function generateRegionRoutesFromSnapshots(originRegionId, destinationRegionId) {\r\n    const from = Number(originRegionId);\r\n    const to = Number(destinationRegionId || originRegionId);\r\n    try {\r\n        const [snapA, snapB] = await Promise.all([\r\n            fetchRegionOrdersSnapshot(from),\r\n            fetchRegionOrdersSnapshot(to)\r\n        ]);\r\n\r\n        if (!snapA || !snapB || !snapA.best_quotes || !snapB.best_quotes) return [];\r\n        const routes = [];\r\n        // Iterate over intersection of types present in both snapshots\r\n        const typeIds = Object.keys(snapA.best_quotes);\r\n        for (const t of typeIds) {\r\n            const a = snapA.best_quotes[t];\r\n            const b = snapB.best_quotes[t];\r\n            if (!a || !b) continue;\r\n            const sellA = a.best_sell; // we buy at origin's best sell\r\n            const buyB = b.best_buy;   // we sell to destination's best buy\r\n            if (!sellA || !buyB) continue;\r\n            const profit = (buyB.price || 0) - (sellA.price || 0);\r\n            if (profit <= 0) continue;\r\n            const qty = Math.min(Number(sellA.volume_remain || 0), Number(buyB.volume_remain || 0));\r\n            const roi = sellA.price > 0 ? (profit / sellA.price) * 100 : 0;\r\n            routes.push({\r\n                type_id: Number(t),\r\n                origin_id: sellA.location_id,\r\n                destination_id: buyB.location_id,\r\n                sell_price: sellA.price,\r\n                buy_price: buyB.price,\r\n                profit_per_unit: profit,\r\n                profit_margin: roi,\r\n                max_volume: qty,\r\n                origin_region_id: from,\r\n                destination_region_id: to,\r\n                _fallback: true\r\n            });\r\n        }\r\n        // Sort by profit per unit desc and cap to a reasonable size\r\n        return routes.sort((x, y) => (y.profit_per_unit || 0) - (x.profit_per_unit || 0)).slice(0, 5000);\r\n    } catch {\r\n        return [];\r\n    }\r\n}\r\n\r\n// Prefer snapshots only: use precomputed region_hauling artifact; if missing/empty, derive from region_orders snapshots; never call live Azure route API\r\nexport async function fetchRegionHaulingSnapshotsOnly(originRegionId, destinationRegionId = null) {\r\n    // Build from region_orders snapshots only (no region_hauling artifacts)\r\n    return generateRegionRoutesFromSnapshots(originRegionId, destinationRegionId || originRegionId);\r\n}"],"names":["HISTORY_CACHE_KEY","async","fetchMarketOrders","typeId","regionId","locationId","isBuyOrder","params","URLSearchParams","type_id","append","console","log","PLEX_REGION_ID","Number","snap","fetchRegionOrdersSnapshot","best_quotes","entry","buy","best_buy","is_buy_order","region_id","buyOrders","sellOrders","best_sell","meta","source","last_updated","url","AZURE_BASE","response","fetchWithRetry","Error","result","length","azureError","error","fetchMarketHistory","days","key","cache","raw","localStorage","getItem","JSON","parse","readHistoryCache","now","Date","cached","Array","isArray","data","lastUpdated","toDateString","ESI_BASE","encodeURIComponent","fetch","headers","ok","statusText","status","normalized","filter","e","date","sort","a","b","slice","merged","map","Map","set","from","values","setItem","stringify","writeHistoryCache","persistHistory","json","warn","message","fetchUniverseMarketHistory","hubs","historyLists","Promise","all","rid","list","dateMap","forEach","index","has","totalVolume","totalValue","highest","lowest","Infinity","orderCount","bucket","get","vol","volume","avg","average","Math","max","min","order_count","size","aggregated","item","fetchRegionHaulingSnapshotsOnly","originRegionId","destinationRegionId","to","snapA","snapB","routes","typeIds","Object","keys","t","sellA","buyB","profit","price","qty","volume_remain","roi","push","origin_id","location_id","destination_id","sell_price","buy_price","profit_per_unit","profit_margin","max_volume","origin_region_id","destination_region_id","_fallback","x","y","generateRegionRoutesFromSnapshots"],"mappings":"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"}